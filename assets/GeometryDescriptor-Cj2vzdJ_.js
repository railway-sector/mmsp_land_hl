import{fd as y,fe as u,ff as R,bD as d,cE as m}from"./index-YAG6QmBT.js";class f{constructor(t){this.geometry=t,this.spatialReference=t.spatialReference}export(){return this._exporter(this.coordinates,this.spatialReference)}clone(t){const n=new f(this.geometry);return n.spatialReference=this.spatialReference,n.coordinates=t??this.coordinates.map(s=>s.clone()),n._exporter=this._exporter,n}async project(t,n){if(this.spatialReference.equals(t))return this.clone();await y([{source:this.spatialReference,dest:t}],{signal:n});const s=new u({spatialReference:this.spatialReference,points:this.coordinates.map(p=>[p.x,p.y])}),r=R(s,t);if(!r)return null;const a=this.coordinates.map((p,i)=>{const l=p.clone(),o=r.points[i];return l.x=o[0],l.y=o[1],l}),e=this.clone(a);return e.spatialReference=t,e}static fromGeometry(t){const n=new f(t);if(t instanceof f)return n.coordinates=t.coordinates.map(s=>s.clone()),n._exporter=(s,r)=>{const a=t.clone(s);return a.spatialReference=r,a},n;switch(t.type){case"point":{const s=t,{hasZ:r,hasM:a}=s;return n.coordinates=r&&a?[new c(s.x,s.y,s.z,s.m)]:r?[new c(s.x,s.y,s.z)]:a?[new c(s.x,s.y,null,s.m)]:[new c(s.x,s.y)],n._exporter=(e,p)=>t.hasM?new m(e[0].x,e[0].y,e[0].z,e[0].m,p):new m(e[0].x,e[0].y,e[0].z,p),n}case"multipoint":{const s=t,{hasZ:r,hasM:a}=s;return n.coordinates=r&&a?s.points.map(e=>new c(e[0],e[1],e[2],e[3])):r?s.points.map(e=>new c(e[0],e[1],e[2])):a?s.points.map(e=>new c(e[0],e[1],null,e[2])):s.points.map(e=>new c(e[0],e[1])),n._exporter=(e,p)=>t.hasM?new u({points:e.map(i=>[i.x,i.y,i.z??0,i.m??0]),hasZ:!0,hasM:!0,spatialReference:p}):new u({points:e.map(i=>[i.x,i.y,i.z??0]),spatialReference:p}),n}case"polyline":{const s=t,r=[],a=[],{hasZ:e,hasM:p}=t;let i=0;for(const l of s.paths)if(a.push([i,i+l.length]),i+=l.length,e&&p)for(const o of l)r.push(new c(o[0],o[1],o[2],o[3]));else if(e)for(const o of l)r.push(new c(o[0],o[1],o[2]));else if(p)for(const o of l)r.push(new c(o[0],o[1],null,o[2]));else for(const o of l)r.push(new c(o[0],o[1]));return n.coordinates=r,n._exporter=(l,o)=>{const w=t.hasM?l.map(h=>[h.x,h.y,h.z??0,h.m??0]):l.map(h=>[h.x,h.y,h.z??0]),x=a.map(h=>w.slice(h[0],h[1]));return new d({paths:x,hasM:t.hasM,hasZ:!0,spatialReference:o})},n}}}}class c{constructor(t,n,s=null,r=null,a=null,e=null){this.x=t,this.y=n,this.z=s,this.m=r,this.tile=a,this.elevationTile=e}clone(){return new c(this.x,this.y,this.z,this.m)}}export{f as r};
